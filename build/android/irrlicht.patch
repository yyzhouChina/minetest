diff -Naur irrlicht/include/IEventReceiver.h irrlicht.patched/include/IEventReceiver.h
--- irrlicht/include/IEventReceiver.h	2014-03-02 01:18:38.644198744 +0100
+++ irrlicht.patched/include/IEventReceiver.h	2014-03-02 01:30:11.896215194 +0100
@@ -382,6 +382,8 @@
         //! Reset variables.
 		void clear()
 		{
+			PointerCount = 0;
+			ChangedPointerID = -1;
 			for (u16 i = 0; i < NUMBER_OF_MULTI_TOUCHES; ++i)
             {
 				Touched[i] = 0;
@@ -389,8 +391,15 @@
 				Y[i] = 0;
 				PrevX[i] = 0;
 				PrevY[i] = 0;
+				ID[i] = 0;
 			}
 		}
+		// Number of pointers
+		u8 PointerCount;
+
+		//id changed valid for not move events only
+		s32 ChangedPointerID;
+
         
         // Status of simple touch.
         u8 Touched[NUMBER_OF_MULTI_TOUCHES];
@@ -406,6 +415,9 @@
         
         // Previous Y position of simple touch.
 		s32 PrevY[NUMBER_OF_MULTI_TOUCHES];
+		
+		// pointer ids
+		s32 ID[NUMBER_OF_MULTI_TOUCHES];
         
 		//! Type of multi touch event
 		EMULTI_TOUCH_INPUT_EVENT Event;
diff -Naur irrlicht/source/Irrlicht/Android/CIrrDeviceAndroid.cpp irrlicht.patched/source/Irrlicht/Android/CIrrDeviceAndroid.cpp
--- irrlicht/source/Irrlicht/Android/CIrrDeviceAndroid.cpp	2014-03-02 01:18:26.948198467 +0100
+++ irrlicht.patched/source/Irrlicht/Android/CIrrDeviceAndroid.cpp	2014-03-02 01:34:21.316221112 +0100
@@ -37,6 +37,7 @@
 #ifdef _DEBUG
 	setDebugName("CIrrDeviceAndroid");
 #endif
+	previousMotionData = new core::map<s32, irr::core::vector2d<s32> >;
 
 	// Get the interface to the native Android activity.
 	Android = (android_app*)(param.PrivateData);
@@ -136,7 +137,7 @@
 	nanosleep(&ts, NULL);
 
 	if (pauseTimer && !wasStopped)
-		Timer->start();	
+		Timer->start(); 
 }
 
 void CIrrDeviceAndroid::setWindowCaption(const wchar_t* text)
@@ -273,7 +274,11 @@
 	{
 		SEvent Event;
 		s32 PointerCount = AMotionEvent_getPointerCount(androidEvent);
-		s32 EventAction = AMotionEvent_getAction(androidEvent);
+		s32 AndroidEventAction = AMotionEvent_getAction(androidEvent);
+		s32 EventAction =  AndroidEventAction & AMOTION_EVENT_ACTION_MASK;
+		s32 ChangedPointerIdx =
+				(AndroidEventAction & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK)
+				>> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;
 
 		bool MultiTouchEvent = true;
 		bool Touched = false;
@@ -281,6 +286,7 @@
 		switch (EventAction)
 		{
 		case AMOTION_EVENT_ACTION_DOWN:
+		case AMOTION_EVENT_ACTION_POINTER_DOWN:
 			Event.MultiTouchInput.Event = EMTIE_PRESSED_DOWN;
 			Touched = true;
 			break;
@@ -289,6 +295,7 @@
 			Touched = true;
 			break;
 		case AMOTION_EVENT_ACTION_UP:
+		case AMOTION_EVENT_ACTION_POINTER_UP:
 			Event.MultiTouchInput.Event = EMTIE_LEFT_UP;
 			break;
 		default:
@@ -300,25 +307,232 @@
 		{
 			Event.EventType = EET_MULTI_TOUCH_EVENT;
 			Event.MultiTouchInput.clear();
+			Event.MultiTouchInput.PointerCount = PointerCount;
+
+			if (EventAction != AMOTION_EVENT_ACTION_MOVE)
+				Event.MultiTouchInput.ChangedPointerID =
+						AMotionEvent_getPointerId(androidEvent,ChangedPointerIdx);
+
+			core::map<s32, irr::core::vector2d<s32> > *newMotionData =
+					new core::map<s32, irr::core::vector2d<s32> >;
 
 			for (s32 i = 0; i < PointerCount; ++i)
 			{
 				if (i >= NUMBER_OF_MULTI_TOUCHES)
 					break;
 
-				Event.MultiTouchInput.PrevX[i] = 0; // TODO
-				Event.MultiTouchInput.PrevY[i] = 0; // TODO
-				Event.MultiTouchInput.X[i] = AMotionEvent_getX(androidEvent, i);
-				Event.MultiTouchInput.Y[i] = AMotionEvent_getY(androidEvent, i);
-				Event.MultiTouchInput.Touched[i] = Touched;
+				s32 x = AMotionEvent_getX(androidEvent, i);
+				s32 y = AMotionEvent_getY(androidEvent, i);
+				Event.MultiTouchInput.X[i] = x;
+				Event.MultiTouchInput.Y[i] = y;
+
+				s32 id = AMotionEvent_getPointerId(androidEvent, i);
+				Event.MultiTouchInput.ID[i] = id;
+
+				core::map<s32, irr::core::vector2d<s32> >::Node *previousMotion;
+				if ((previousMotion = device->previousMotionData->find(id))) {
+					Event.MultiTouchInput.PrevX[i] = previousMotion->getValue().X;
+					Event.MultiTouchInput.PrevY[i] = previousMotion->getValue().Y;
+				} else {
+					Event.MultiTouchInput.PrevX[i] = x;
+					Event.MultiTouchInput.PrevY[i] = y;
+				}
+
+				if ((Event.MultiTouchInput.Touched[i] = Touched || (ChangedPointerIdx != id)))
+					(*newMotionData)[id] = core::vector2d<s32>(x, y);
 			}
 
+
+
+			delete device->previousMotionData;
+			device->previousMotionData = newMotionData;
 			device->postEventFromUser(Event);
 
 			Status = 1;
 		}
 	}
 
+	if( AInputEvent_getType( androidEvent ) == AINPUT_EVENT_TYPE_KEY )
+	{
+		SEvent irrEvent;
+		irrEvent.EventType = EET_KEY_INPUT_EVENT;
+		s32 action = AKeyEvent_getAction(androidEvent);
+		s32 meta = AKeyEvent_getMetaState(androidEvent);
+		irrEvent.KeyInput.Char = 0;
+		irrEvent.KeyInput.Control = false;//TODO: Control
+		irrEvent.KeyInput.Shift = (meta & AMETA_SHIFT_ON)!=0;
+		irrEvent.KeyInput.PressedDown = (action==AKEY_EVENT_ACTION_DOWN);//AKEY_EVENT_ACTION_UP
+		s32 key = AKeyEvent_getKeyCode(androidEvent);
+		if(key==AKEYCODE_HOME){
+			irrEvent.KeyInput.Key = KEY_HOME;
+		}else if(key==AKEYCODE_BACK){//the back button will not exit the app anymore, KEY_CANCEL makes sense to me
+			irrEvent.KeyInput.Key = KEY_CANCEL;//KEY_BACK;
+		}else if(key>=AKEYCODE_0 && key<=AKEYCODE_9){
+			irrEvent.KeyInput.Key = (EKEY_CODE)(key-AKEYCODE_0+KEY_KEY_0);
+			if(!irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = (wchar_t)(key-AKEYCODE_0)+L'0';
+			}else{
+				if(key == AKEYCODE_2){
+					irrEvent.KeyInput.Char = L'@';
+				}else if(key == AKEYCODE_1){
+					irrEvent.KeyInput.Char = L'!';
+				}else if(key == AKEYCODE_3){
+					irrEvent.KeyInput.Char = L'#';
+				}else if(key == AKEYCODE_4){
+					irrEvent.KeyInput.Char = L'$';
+				}else if(key == AKEYCODE_5){
+					irrEvent.KeyInput.Char = L'%';
+				}else if(key == AKEYCODE_6){
+					irrEvent.KeyInput.Char = L'^';
+				}else if(key == AKEYCODE_7){
+					irrEvent.KeyInput.Char = L'&';
+				}else if(key == AKEYCODE_8){
+					irrEvent.KeyInput.Char = L'*';
+				}else if(key == AKEYCODE_9){
+					irrEvent.KeyInput.Char = L'(';
+				}else if(key == AKEYCODE_0){
+					irrEvent.KeyInput.Char = L')';
+				}
+			}
+		}else if(key==AKEYCODE_STAR){
+			irrEvent.KeyInput.Key = KEY_KEY_8 ;//US Keyboard
+			irrEvent.KeyInput.Char = L'*';
+		}else if(key==AKEYCODE_POUND){
+			irrEvent.KeyInput.Key = KEY_KEY_3;//British Keyboard
+			irrEvent.KeyInput.Char = L'Â£';
+		}else if(key==AKEYCODE_DPAD_UP){
+			irrEvent.KeyInput.Key = KEY_UP;
+		}else if(key==AKEYCODE_DPAD_DOWN){
+			irrEvent.KeyInput.Key = KEY_DOWN;
+		}else if(key==AKEYCODE_DPAD_LEFT){
+			irrEvent.KeyInput.Key = KEY_LEFT;
+		}else if(key==AKEYCODE_DPAD_RIGHT){
+			irrEvent.KeyInput.Key = KEY_RIGHT;
+		}else if(key>=AKEYCODE_A && key<=AKEYCODE_Z){
+			irrEvent.KeyInput.Key = (EKEY_CODE)(key-AKEYCODE_A+KEY_KEY_A);
+			if(!irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = (wchar_t)(key-AKEYCODE_A)+L'a';
+			}else{
+				irrEvent.KeyInput.Char = (wchar_t)(key-AKEYCODE_A)+L'A';
+			}
+		}else if(key==AKEYCODE_COMMA){
+			irrEvent.KeyInput.Key = KEY_COMMA;
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'<';
+			}else{
+				irrEvent.KeyInput.Char = L',';
+			}
+		}else if(key==AKEYCODE_PERIOD){
+			irrEvent.KeyInput.Key = KEY_PERIOD;
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'>';
+			}else{
+				irrEvent.KeyInput.Char = L'.';
+			}
+		}else if(key==AKEYCODE_ALT_LEFT){
+			irrEvent.KeyInput.Key = KEY_LMENU;
+		}else if(key==AKEYCODE_ALT_RIGHT){
+			irrEvent.KeyInput.Key = KEY_RMENU;
+		}else if(key==AKEYCODE_SHIFT_LEFT){
+			irrEvent.KeyInput.Key = KEY_LSHIFT;
+		}else if(key==AKEYCODE_SHIFT_RIGHT){
+			irrEvent.KeyInput.Key = KEY_RSHIFT;
+		}else if(key==AKEYCODE_TAB){
+			irrEvent.KeyInput.Key = KEY_TAB;
+			irrEvent.KeyInput.Char = L'\t';
+		}else if(key==AKEYCODE_SPACE){
+			irrEvent.KeyInput.Key = KEY_SPACE;
+			irrEvent.KeyInput.Char = L' ';
+		}else if(key==AKEYCODE_ENTER){
+			irrEvent.KeyInput.Key = KEY_RETURN;
+			irrEvent.KeyInput.Char = L'\n';
+		}else if(key==AKEYCODE_DEL){
+			irrEvent.KeyInput.Key = KEY_BACK;
+		}else if(key==AKEYCODE_MINUS){
+			irrEvent.KeyInput.Key = KEY_MINUS;
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'_';
+			}else{
+				irrEvent.KeyInput.Char = L'-';
+			}
+		}else if(key==AKEYCODE_EQUALS){
+			irrEvent.KeyInput.Key = KEY_PLUS;//US Keyboard
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'+';
+			}else{
+				irrEvent.KeyInput.Char = L'=';
+			}
+		}else if(key==AKEYCODE_LEFT_BRACKET){
+			irrEvent.KeyInput.Key = KEY_OEM_4;//US Keyboard
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'{';
+			}else{
+				irrEvent.KeyInput.Char = L'[';
+			}
+		}else if(key==AKEYCODE_RIGHT_BRACKET){
+			irrEvent.KeyInput.Key = KEY_OEM_6;//US Keyboard
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'}';
+			}else{
+				irrEvent.KeyInput.Char = L']';
+			}
+		}else if(key==AKEYCODE_BACKSLASH){
+			irrEvent.KeyInput.Key = KEY_OEM_5;//US Keyboard
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'|';
+			}else{
+				irrEvent.KeyInput.Char = L'\\';
+			}
+		}else if(key==AKEYCODE_SEMICOLON){
+			irrEvent.KeyInput.Key = KEY_OEM_1;//US Keyboard
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L':';
+			}else{
+				irrEvent.KeyInput.Char = L';';
+			}
+		}else if(key==AKEYCODE_APOSTROPHE){
+			irrEvent.KeyInput.Key = KEY_OEM_7;//US Keyboard
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'\"';
+			}else{
+				irrEvent.KeyInput.Char = L'\'';
+			}
+		}else if(key==AKEYCODE_SLASH){
+			irrEvent.KeyInput.Key = KEY_OEM_2;//US Keyboard
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'?';
+			}else{
+				irrEvent.KeyInput.Char = L'/';
+			}
+		}else if(key==AKEYCODE_AT){
+			irrEvent.KeyInput.Key = KEY_KEY_2;//US Keyboard
+			irrEvent.KeyInput.Char = L'@';
+		}else if(key==AKEYCODE_PLUS){
+			irrEvent.KeyInput.Key = KEY_PLUS;
+			irrEvent.KeyInput.Char = L'+';
+		}else if(key==AKEYCODE_MENU){//Menubutton of the unhidable toolbar
+			irrEvent.KeyInput.Key = KEY_MENU;
+		}else if(key==AKEYCODE_MEDIA_PLAY_PAUSE){
+			irrEvent.KeyInput.Key = KEY_PLAY;//hmmm
+		}else if(key==AKEYCODE_PAGE_UP){
+			irrEvent.KeyInput.Key = KEY_PRIOR;
+		}else if(key==AKEYCODE_PAGE_DOWN){
+			irrEvent.KeyInput.Key = KEY_NEXT;
+		}else if(key==AKEYCODE_GRAVE){
+			irrEvent.KeyInput.Key = KEY_OEM_3;//US Keyboard
+			if(irrEvent.KeyInput.Shift){
+				irrEvent.KeyInput.Char = L'~';
+			}else{
+				irrEvent.KeyInput.Char = L'`';
+			}
+		}else{
+			//__android_log_print(ANDROID_LOG_ERROR, "Unhandled Key", "Code: %i Shift: %i\n", key, (int)irrEvent.KeyInput.Shift);
+			return 0;
+		}
+
+		device->postEventFromUser(irrEvent);
+		Status = 1;
+		}
 	return Status;
 }
 
diff -Naur irrlicht/source/Irrlicht/Android/CIrrDeviceAndroid.h irrlicht.patched/source/Irrlicht/Android/CIrrDeviceAndroid.h
--- irrlicht/source/Irrlicht/Android/CIrrDeviceAndroid.h	2014-03-02 01:18:26.948198467 +0100
+++ irrlicht.patched/source/Irrlicht/Android/CIrrDeviceAndroid.h	2014-03-02 01:31:44.860217400 +0100
@@ -13,6 +13,7 @@
 #include "IrrlichtDevice.h"
 #include "IImagePresenter.h"
 #include "ICursorControl.h"
+#include "irrMap.h"
 
 #include <android/sensor.h>
 #include <android_native_app_glue.h>
@@ -65,6 +66,8 @@
 		void createDriver();
 
 		video::SExposedVideoData& getExposedVideoData();
+		
+		core::map<s32, irr::core::vector2d<s32> > *previousMotionData;
 
 		android_app* Android;
 		ASensorManager* SensorManager;
